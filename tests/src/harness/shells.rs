use crate::harness::autojumpers::Autojumper;
use std::fs;
use std::io::Write;
use std::path::Path;

#[derive(PartialEq)]
pub enum Shell {
    Bash,
    Zsh,
    Fish,
}

pub struct ShellCmd<'a> {
    pub cmd: &'a str,
    pub env: Vec<(&'a str, String)>,
}

impl Shell {
    pub fn name(&self) -> &'static str {
        match self {
            &Shell::Bash => "bash",
            &Shell::Zsh => "zsh",
            &Shell::Fish => "fish",
        }
    }

    pub fn setup(&self, root: &Path, autojump: &dyn Autojumper, ps1: &str, preinit: &str) {
        let rc_file = match *self {
            Shell::Bash | Shell::Zsh => root.join(format!("home/pazi/.{}rc", self.name())),
            Shell::Fish => root.join(format!("home/pazi/.config/fish/config.fish")),
        };

        let rc_template = match *self {
            Shell::Bash => format!(
                r#"#Autogenerated by pazi integ tests
{preinit}
export PS1="{ps1}" # sep so we know when our commands finished
export PATH=$(dirname "{bin_path}"):$PATH
{init}
"#,
                bin_path = autojump.bin_path(),
                init = autojump.init_for(self),
                ps1 = ps1,
                preinit = preinit,
            ),
            Shell::Zsh => format!(
                r#"#Autogenerated by pazi integ tests
unsetopt zle
{preinit}
export PS1="{ps1}" # sep so we know when our commands finished
export PATH=$(dirname "{bin_path}"):$PATH
{init}
"#,
                bin_path = autojump.bin_path(),
                init = autojump.init_for(self),
                ps1 = ps1,
                preinit = preinit,
            ),
            Shell::Fish => format!(
                r#"#Autogenerated by pazi integ tests
{preinit}
set fish_greeting
function fish_prompt
    echo -n "{ps1}" # sep so we know when our commands finished
end
set PATH (dirname {bin_path}) $PATH
{init}
"#,
                bin_path = autojump.bin_path(),
                init = autojump.init_for(self),
                ps1 = ps1,
                preinit = preinit,
            ),
        };

        match *self {
            Shell::Fish => {
                fs::create_dir_all(root.join("home/pazi/.config/fish")).unwrap();
                // hack to prevent 'fish_config_interactive' trying to spin off a
                // completions update background process
                fs::create_dir_all(root.join("home/pazi/.local/share/fish/generated_completions"))
                    .unwrap();
            }
            Shell::Bash => {
                // hack: create .hushlogin because ubuntu spams in the /etc/bash.bashrc file.
                // Unfortunately, using `--rcfile` on bash doesn't fix this, or else that would be
                // a much more elegant solution (see
                // https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=516152 for why --rcfile
                // doesn't get around that spam).
                fs::create_dir_all(root.join("home/pazi")).unwrap();
                fs::File::create(root.join("home/pazi/.hushlogin")).unwrap();
            }
            _ => {
                fs::create_dir_all(root.join("home/pazi")).unwrap();
            }
        }
        fs::File::create(rc_file)
            .unwrap()
            .write_all(rc_template.as_bytes())
            .unwrap();
    }

    pub fn command(&self, root: &Path) -> ShellCmd {
        let home = root.join("home/pazi").to_string_lossy().to_string();
        ShellCmd {
            cmd: self.name(),
            env: vec![
                ("HOME", home.clone()),
                ("XDG_CONFIG_HOME", format!("{}/.config", home)),
                // for bash on nixos, skip the /etc/bashrc
                // Per a comment above (the .hushlogin stuff), --rcfile doesn't help here :(
                ("__ETC_BASHRC_SOURCED", "1".to_owned()),
            ],
        }
    }
}
