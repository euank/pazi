use std::env;
use std::fs::File;
use std::io::BufRead;
use std::io::BufReader;
use std::io::Write;
use std::path::Path;

fn main() {
    let crate_root = env::var("CARGO_MANIFEST_DIR").expect("build with cargo");
    let bench_spec = Path::new(&crate_root).join("src/benches.csv");

    println!("cargo:rerun-if-changed=src/benches.csv");

    let f = File::open(bench_spec).expect("benches.csv should exist");
    let r = BufReader::new(f);

    let mut code =
        r#"// This file is autogenerated by build.rs based on the contents of src/benches.csv
// Please edit those files to run new benches or change the matrix.

"#
        .to_string();

    for line in r.lines() {
        let line = line.expect("read err");
        if line.starts_with("#") {
            continue;
        }
        let parts = line.split(",").map(|el| el.trim()).collect::<Vec<_>>();
        if parts.len() != 3 {
            panic!("each csv line should have 3 parts");
        }
        let bench_names = parts[0].trim().split(" ");
        let bench_jumpers = parts[1].trim().split(" ");
        let bench_shells = parts[2].trim().split(" ");

        for bench_name in bench_names {
            for jumper in bench_jumpers.clone() {
                for shell in bench_shells.clone() {
                    let fn_name = format!(
                        "{}_{}_{}",
                        bench_name,
                        jumper.to_lowercase(),
                        shell.to_lowercase()
                    );
                    code += format!(
                        r#"
    #[bench]
    fn {0}(b: &mut Bencher) {{
        {1}(b, &{2}, &Shell::{3});
    }}
    "#,
                        &fn_name, &bench_name, &jumper, &shell,
                    )
                    .as_str();
                }
            }
        }
    }

    let out_path = Path::new(&crate_root).join("src/benches_generated.rs");
    let mut output = File::create(&out_path).unwrap();
    output.write_all(code.as_bytes()).unwrap();
}
