use std::env;
use std::path::Path;
use std::fs::File;
use std::io::BufReader;
use std::io::BufRead;
use std::io::Write;

fn main() {
    let crate_root = env::var("CARGO_MANIFEST_DIR").expect("build with cargo");
    let bench_spec = Path::new(&crate_root).join("src/benches.csv");

    println!("cargo:rerun-if-changed=src/benches.csv");

    let f = File::open(bench_spec).expect("benches.csv should exist");
    let r = BufReader::new(f);

    let mut code =
        r#"// This file is autogenerated by build.rs based on the contents of src/benches.csv
// Please edit those files to run new benches or change the matrix.

"#.to_string();

    for line in r.lines() {
        let line = line.expect("read err");
        if line.starts_with("#") {
            continue;
        }
        let parts = line.split(",").map(|el| el.trim()).collect::<Vec<_>>();
        if parts.len() != 3 {
            panic!("each csv line should have 3 parts");
        }
        let bench_name = parts[0].trim();
        let bench_jumpers = parts[1].trim().split(" ");
        let bench_shells = parts[2].trim().split(" ");

        for jumper in bench_jumpers {
            for shell in bench_shells.clone() {
                let fn_name = format!(
                    "{}_{}_{}",
                    bench_name,
                    jumper.to_lowercase(),
                    shell.to_lowercase()
                );
                code += format!(
                    r#"
#[bench]
fn {0}(b: &mut Bencher) {{
    {1}(b, &{2}, &Shell::{3});
}}
"#,
                    &fn_name, &bench_name, &jumper, &shell
                ).as_str();
            }
        }
    }

    let out_path = Path::new(&crate_root).join("src/benches_generated.rs");
    let mut output = File::create(&out_path).unwrap();
    output.write_all(code.as_bytes()).unwrap();
}
